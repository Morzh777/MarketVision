import { Injectable } from '@nestjs/common';
import { fileLogger } from '../utils/logger';
import { EnhancedPriceAnomalyService } from './enhanced-price-anomaly.service';

@Injectable()
export class ProductGroupingService {
  constructor(private readonly priceAnomalyService: EnhancedPriceAnomalyService) {}

  groupAndSelectCheapest(products: any[], getModelKey: (product: any) => string, category: string = 'unknown'): any[] {
    if (!products.length) return [];
    fileLogger.log(`–ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ ${products.length} –ø—Ä–æ–¥—É–∫—Ç–æ–≤...`);
    const groups = new Map<string, any[]>();
    for (const product of products) {
      const modelKey = getModelKey(product);
      if (!modelKey) continue;
      if (!groups.has(modelKey)) groups.set(modelKey, []);
      groups.get(modelKey)!.push(product);
    }
    const selectedProducts: any[] = [];
    for (const [modelKey, groupProducts] of groups) {
      const prices = groupProducts.map(p => p.price);
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const avgPrice = Math.round(prices.reduce((a, b) => a + b, 0) / prices.length);
      fileLogger.log(`–ì—Ä—É–ø–ø–∞: ${modelKey} | —Ç–æ–≤–∞—Ä—ã: ${groupProducts.map(p => `[id:${p.id}, price:${p.price}, source:${p.source}, query:${p.query}]`).join(' ')} | min: ${minPrice}‚ÇΩ, max: ${maxPrice}‚ÇΩ, avg: ${avgPrice}‚ÇΩ`);
      if (!groupProducts.length) continue;
      // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ü–µ–Ω–µ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
      const sortedByPrice = [...groupProducts].sort((a, b) => a.price - b.price);
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∞–Ω–æ–º–∞–ª–∏—é —Ü–µ–Ω—ã —Å –ø–æ–º–æ—â—å—é –Ω–æ–≤–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
      const anomalyResult = this.priceAnomalyService.detectAnomalies(sortedByPrice, category);
      let anomalyIds = anomalyResult.anomalousProducts.map(a => a.id);
      // –ï—Å–ª–∏ –µ—Å—Ç—å –∞–Ω–æ–º–∞–ª–∏–∏ ‚Äî –ø–æ–º–µ—á–∞–µ–º –∏—Ö
      sortedByPrice.forEach(product => {
        if (anomalyIds.includes(product.id)) {
          product.toAI = true;
          product.reason = 'price-anomaly';
        }
      });
      // –ù–æ–≤—ã–π best practice: –µ—Å–ª–∏ —Å–∞–º—ã–π –¥–µ—à—ë–≤—ã–π –≤–∞–ª–∏–¥–Ω—ã–π –Ω–µ-–∞–∫—Å–µ—Å—Å—É–∞—Ä ‚Äî –≤—Å–µ–≥–¥–∞ –≤–∫–ª—é—á–∞–µ–º
      const cheapest = sortedByPrice[0];
      const { isAccessoryByCategory } = require('../utils/is-accessory');
      if (
        cheapest &&
        !isAccessoryByCategory(cheapest.name, category) &&
        (cheapest.validationReason?.includes('validated') || cheapest.isValid)
      ) {
        fileLogger.log(`[ProductGroupingService] üö© –í–∫–ª—é—á–∞—é —Å–∞–º—ã–π –¥–µ—à—ë–≤—ã–π –≤–∞–ª–∏–¥–Ω—ã–π –Ω–µ-–∞–∫—Å–µ—Å—Å—É–∞—Ä: ${cheapest.name} (id:${cheapest.id}, price:${cheapest.price}, validationReason:${cheapest.validationReason}, category:${category})`);
        // –°–±—Ä–æ—Å —Ñ–ª–∞–≥–æ–≤ –∞–Ω–æ–º–∞–ª–∏–∏!
        cheapest.toAI = false;
        if (cheapest.reason === 'price-anomaly') delete cheapest.reason;
        selectedProducts.push(cheapest);
        continue;
      }
      // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ –∞–Ω–æ–º–∞–ª—å–Ω—ã–µ —Å–Ω–∞—á–∞–ª–∞
      let selected = null;
      for (const product of sortedByPrice) {
        // –ï—Å–ª–∏ —Ç–æ–≤–∞—Ä –Ω–µ –∞–Ω–æ–º–∞–ª–∏—è ‚Äî —Å—Ä–∞–∑—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
        if (!product.toAI) {
          selected = product;
          break;
        }
      }
      // –ï—Å–ª–∏ –≤—Å–µ –∞–Ω–æ–º–∞–ª—å–Ω—ã–µ ‚Äî –±–µ—Ä—ë–º –ø–µ—Ä–≤—ã–π –∞–Ω–æ–º–∞–ª—å–Ω—ã–π (–æ–Ω –ø–æ–π–¥—ë—Ç –≤ AI)
      if (!selected && sortedByPrice.length > 0) {
        selected = sortedByPrice[0];
      }
      if (selected) {
        selectedProducts.push(selected);
      }
    }
    fileLogger.log(`–ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: ${selectedProducts.length} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤`);
    return selectedProducts;
  }
} 